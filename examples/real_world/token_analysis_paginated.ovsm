;; Per-token wallet analysis with pagination (up to 10,000 txs)
(do
  (define target "REVXui3vBCcsDHd7oUaiTNc885YiXT773yoD8DuFuck")

  ;; Fetch transactions with pagination
  (define all_txs [])
  (define batch_size 100)
  (define max_txs 10000)
  (define before null)
  (define keep_fetching true)

  (while (and keep_fetching (< (count all_txs) max_txs))
    (define params
      (if (null? before)
        {:address target :limit batch_size}
        {:address target :limit batch_size :before before}))

    (define resp (get_account_transactions params))
    (define batch (get resp "transactions"))

    (when (array? batch)
      (set! all_txs (concat all_txs batch))

      ;; Get last signature for pagination
      (when (> (count batch) 0)
        (define last_tx (get batch (- (count batch) 1)))
        (set! before (get last_tx "signature")))

      ;; Stop if we got fewer than batch_size (no more txs)
      (when (< (count batch) batch_size)
        (set! keep_fetching false))))

  ;; Track all token flows (not just SOL)
  (define token_flows {})

  (for (tx all_txs)
    (define xfers (get tx "transfers"))
    (when (array? xfers)
      (for (xf xfers)
        (define addr (get xf "account"))
        (define chg (get xf "change"))
        (define mnt (get xf "mint"))

        (when (and addr mnt (!= addr target))
          ;; Initialize token if not exists
          (when (null? (get token_flows mnt))
            (set! token_flows (set token_flows mnt {:inflow {} :outflow {}})))

          (define tok_data (get token_flows mnt))

          (if (< chg 0)
            ;; Inflow (negative change = sent TO target)
            (do
              (define inf_map (get tok_data "inflow"))
              (define prev (get inf_map addr))
              (set! inf_map (set inf_map addr (+ (if (null? prev) 0 prev) (- 0 chg))))
              (set! tok_data (set tok_data "inflow" inf_map))
              (set! token_flows (set token_flows mnt tok_data)))
            ;; Outflow (positive change = received FROM target)
            (do
              (define out_map (get tok_data "outflow"))
              (define prev (get out_map addr))
              (set! out_map (set out_map addr (+ (if (null? prev) 0 prev) chg)))
              (set! tok_data (set tok_data "outflow" out_map))
              (set! token_flows (set token_flows mnt tok_data))))))))

  ;; Format results per token
  (define token_results [])
  (define mints (keys token_flows))

  (for (mint mints)
    (define tok_data (get token_flows mint))
    (define inf_map (get tok_data "inflow"))
    (define out_map (get tok_data "outflow"))
    (define inf_list (entries inf_map))
    (define out_list (entries out_map))

    (set! token_results (append token_results {
      :token mint
      :top_5_inflow (take 5 inf_list)
      :top_5_outflow (take 5 out_list)
      :total_inflow_addresses (count inf_list)
      :total_outflow_addresses (count out_list)
    })))

  {:wallet target
   :total_txs (count all_txs)
   :tokens_analyzed (count mints)
   :token_analysis token_results})
